#!/bin/bash
# dw: Docker wrapper
# Shell script for building and managing docker containers on single host installations
# Requirements: docker, wget

# TODO: Make it macos compatible

scriptname="dw"
scriptbuildnum="0.6"
scriptbuilddate="2016-08-10"

# This script needs to be run as root.
# If it's not run as root, then re-exec using sudo
[ "$(whoami)" == "root" ] || exec sudo -- "$0" "$@"

### VARS

WHITE="\033[1;37m"
CYAN="\033[1;36m"
GREEN="\033[1;32m"
NO_COLOR="\033[0m"

# Supported parameters and defaults where appropriate
name=
description=
image=
volumes=
nettype=bridge
localip=
# Guess the appropriate adapter name
adapter=$(ip -o link show | awk -F'[ :]+' '{if ($9 == "UP" && $2 ~ /^en/ ) { print $2 }}')
network=bridge
subnet=
ports=
options=
# depends=

unit_template=
# dw_template=
dw_dir="$HOME/.bin"

# Read container specific parameters
# shellcheck source=/dev/null
. "$build_dir/$build_file"

# Assign defaults if parameters are still blank
[ -z "$image" ] && image=$name
[ -n "$subnet" ] && subnet_opts="--subnet $subnet"
[ -z "$*" ] && set -- start

# Make a list of the dw functions
fns=$(awk '/^[0-9a-zA-Z]+\s*\(\)/ {print $1}' $0 $build_dir/$build_file)

[ "$1" == "help" ] && display_help && exit

# Find the parameter file
if [ -d "$1" ]; then
	build_dir=`cd "$1" && pwd`
	build_file="DWfile"
	shift
elif [ -f "$1" ]; then
	build_dir=`cd "$( dirname "$1" )" && pwd`
	build_file="$(basename "$1")"
	shift
else
	build_dir=$(pwd)
	build_file="DWfile"
fi

### FUNCTIONS

display_ver () {
  echo "$scriptname version $scriptbuildnum - $scriptbuilddate"
}

display_help () {
  display_ver   # Print script-title, build-number, and build-date
  cat <<-EOF

Shell system for building and managing docker containers
Run each function in succession
USAGE: $scriptname [BUILD-DIR | BUILD-FILE] [function1] [function2] [...]
	No arguments: $scriptname start
EOF
}

dwfile_template () {
  cat <<-EOF
# Docker wrapper configuration file

### CONTAINER CONFIGURATION ###

# The name of the container
name=sample

# A one line description
description="A sample docker container"

# The image label. If left blank, the container name is used
image=

# Volume options. Passed directly to `docker create`
# volumes="-v /etc/localtime:/etc/localtime:ro -v /opt/config/$name:/config -v /data:/data"
volumes="-v /etc/localtime:/etc/localtime:ro \
-v /opt/config/$name:/config \
-v /data:/data"

# Type of network setup
# Options are:
# - (blank): Defaults to bridge
# - bridge: Use a docker bridge network
# - pipework: Create the container without networking, then use pipework to
#             give the container an interface and IP address on the host's
#             network adapter using macvlan
nettype=

# IP address to bind to the container
# - If `nettype=bridge`, use this host IP address to publish ports. If the host
#   doesn't have the IP address configured, then it will be added. Specify in
#   CIDR format.
#   localip="192.168.0.89/24"
# - If `nettype=pipework`, give the container this IP address on the host's
#   local network using a macvlan interface. Use the format below.
#   localip="192.168.0.89/24@192.168.0.1"
localip=

# Host adapter to bind the container to if `nettype=pipework`. If unspecified,
# a guess is made
# adapter=eth0
adapter=

# The name of the docker network to connect to. It will be created if it doesn't
# already exist. Defaults to `bridge`
# network=netname
network=

# The subnet of the docker network, in CIDR format
# subnet="172.20.0.0/16"
subnet=

# IP ports to wire from container to host, using same port number on each side
# Specify ports in one of these formats
# - Port numbers optionally followed by "/udp", separated by space, e.g.:
#   ports="80 443 53/udp"
# - Host port, ":", container port, e.g.:
#   ports="80:8080 443:8443 8053:53/udp"
# - docker publish syntax, e.g.:
#   ports="-p $localip:80:8080 -p $localip:443:8443 -p $localip:8053:53/udp"
ports=

# Additional options to pass to `docker create`
# options="--log-opt max-size=10m"
options="--log-opt max-size=10m"

# Adds a systemd unit as a service dependency when running `install` to install
# the container as a system service
# depends=other_container
depends=

### OVERRIDE FUNCTIONS ###
EOF
}

unit_template () {
  if [ -n "$unit_template" ]; then
    cat "$unit_template"
  else
    cat <<-EOF
[Unit]
Description=$description
Requires=docker.service
After=docker.service

[Service]
Restart=always
ExecStart="$dw_dir/dw" "$build_dir/$build_file" run -a
ExecStartPost="$dw_dir/dw" "$build_dir/$build_file" startpost
ExecStop="$dw_dir/dw" "$build_dir/$build_file" stop
ExecStopPost="$dw_dir/dw" "$build_dir/$build_file" stoppost

[Install]
WantedBy=multi-user.target
EOF
  fi
}

exe () {
	# Display and execute the command
	>&2 echo "\$ $*"; "$@"
}

first () {
  # Get the first argument
  echo "$@" | cut -d ' ' -f1
}

rest () {
  echo "$@" | cut -s -d ' ' -f2-
}

contains () {
  case "$2" in
    *"$1"*)
      return 0 ;;
    *)
      return 1 ;;
  esac
}

startswith () {
  # Does $2 start with $1?
  case $2 in
    $1*)
      return 0 ;;
    *)
      return 1 ;;
  esac
}

timeago () {
  # Print how long it has been since the date specified
  # $1: start time
  old=$(date -d "${1}" +%s)
  new=$(date +%s)
  ((t=${new}-${old}))
  ((y=${t}/31556952))
  ((mo=(${t}%31556952)/2592000))
  ((d=(${t}%2592000)/86400))
  ((h=(${t}%86400)/3600))
  ((m=(${t}%3600)/60))
  ((s=${t}%60))

  if [ $y -gt 0 ]; then
    echo -n "$y year"
    [ "$y" == "1" ] || echo -n "s"
  elif [ $mo -gt 0 ]; then
    echo -n "$mo month"
    [ "$mo" == "1" ] || echo -n "s"
  elif [ $d -gt 0 ]; then
    echo -n "$d day"
    [ "$d" == "1" ] || echo -n "s"
  elif [ $h -gt 0 ]; then
    echo -n "$h hour"
    [ "$h" == "1" ] || echo -n "s"
  elif [ $m -gt 0 ]; then
    echo -n "$m minute"
    [ "$m" == "1" ] || echo -n "s"
  else
    echo "$s seconds"
  fi
  echo " ago"
}

isrunning () {
  # This seems like a better way, but it does unexpected things sometimes
  # $(docker inspect -f '{{.State.Running}}' $name 2>/dev/null)
  docker ps | grep -q $name
}

containerexists () {
  docker ps -a  | grep -q $name
}

buildpre () {
  # Run before build
  :
}

buildpost () {
  # Run after build
  :
}

build () {
	# Build the container
  buildpre
  if [ -n "$image" ] && [ -f "$build_dir/Dockerfile" ]; then
  	exe docker build "$@" -t $name $build_dir
  	if [ "$nettype" == "pipework" ]; then
  		exe wget "https://raw.githubusercontent.com/jpetazzo/pipework/master/pipework" \
  			-O "$build_dir/pipework"
  		exe chmod u+x "$build_dir/pipework"
  	fi
  else
    exe docker pull $image
  fi
  buildpost
}

rebuild () {
	# Build the container wtih caching disabled
	clean
	build --no-cache
}

publishports () {
  # Write out docker publish options
  [ -n "$localip" ] && ip_opts="$(echo $localip | cut -d '/' -f1):"
  case $ports in
    -*)
      echo -n $ports
      ;;
    *:*)
      for p in $ports; do
        echo -n "-p $ip_opts$p "
      done
      ;;
    *)
      for p in $ports; do
        echo -n "-p $ip_opts$(echo -n $p | cut -d "/" -f1):$p "
      done
      ;;
    esac
}

createnetwork () {
  # Create the docker network and output `docker create` network options
  case $nettype in
    pipework)
      # pipework will set up the network
      echo -n "--net none"
      ;;
    bridge)
      docker network inspect $network >/dev/null 2>&1 || \
        exe docker network create $subnet_opts $network >/dev/null
      echo -n "--net $network "
      publishports
      ;;
  esac
}

create () {
	# Create the container
	remove
	[ -z "$(docker images -q $name)" ] && build
  # shellcheck disable=SC2046
	exe docker create $volumes $options $(createnetwork) -h $name --name $name "$image"
}

startpre () {
  # Run before starting the container
  :
}

startpost () {
	# Setup after starting container
  if [ "$nettype" == "pipework" ]; then
    # Wait until container is started
    while ! isrunning $name; do
      sleep 1
    done
  	# Add IP address to host adapter using pipework
  	[ "$nettype" == "pipework" ] && \
  		exe "$build_dir/pipework" $adapter $name "$localip"
  fi
	firewall
}

stoppost () {
	# Tear down after stopping container
	:
}

start () {
	# Start the container
	containerexists $name || create
  [ "$nettype" == "bridge" ] && \
    [ -n "$localip" ] && \
    ! ip address show | grep -q "$localip" && \
      exe ip address add "$localip" dev $adapter
  if contains "-a" "$*"; then
    # Start the container, attach STDOUT/STDERR and forward signals
    exe exec docker start "$@" $name
  else
	  exe docker start "$@" $name
    startpost
  fi
}

run () {
  create
  start "$@"
}

startservice () {
	# Start the container's service via systemd
	exe systemctl start "$name"
}

stop () {
	# If the container is running, stop it
	isrunning $name && exe docker stop $name
}

stopservice () {
	# Stop the container's service via systemd
	exe systemctl stop "$name"
}

restart () {
	stop
	start
}

restartservice () {
	exe systemctl stop "$name"
	exe systemctl start "$name"
}

status () {
  # Print the status from docker and systemd
  echo -n "    Image: ";
  imagename=$(docker images -q $name)
  if [ -n "$imagename" ]; then
    echo -n "$imagename, created "
    timeago "`date -d \"$(docker inspect -f '{{.Created}}' $imagename)\"`"
  else
    echo "(no such image)"
  fi
  echo -n "Container: "
  if containerexists $name; then
    echo -n "$name, created "
    timeago "`date -d \"$(docker inspect -f '{{.Created}}' $name)\"`"
  else
    echo "(no such container)"
  fi
  echo -n "    State: "
  if isrunning $name; then
    echo -n -e "${GREEN}Running${NO_COLOR}, started "
    timeago "`date -d \"$(docker inspect -f '{{.State.StartedAt}}' $name)\"`"
    exe docker ps | sed -e "1p" -e "/$name/!d"
  else
    echo "Inactive"
  fi
  if systemctl is-enabled $name >/dev/null 2>&1; then
    echo "---------------------------------------------------------------------"
    exe systemctl status $name
  fi
}

journal () {
  # Print the systemd log entries for the service
  journalctl "$@" -u "$name"
}

cmd () {
  exe docker exec -it $name "$@"
  exit $?
}

logs () {
	# Print the docker logs
	exe docker logs "$@" $name
}

shell () {
	# Attach a shell to a running container
	exe docker exec -it $name /bin/sh
  return 0
}

runshell () {
	# Create a new version of the container with bash as the entry point
	# instead of what was specified in the Dockerfile
	remove
	#exe docker run -it $volumes $options --name $name $name /bin/sh
  # shellcheck disable=SC2046
  exe docker run -it $volumes $options $(createnetwork) -h $name --name $name "$image" /bin/sh
  return 0
}

remove () {
	# Remove container if it exists
	containerexists $name && exe docker rm -f $name
  return 0
}

removeimage () {
	# If the image exists, remove it
	[ "$(docker images -q $image 2>/dev/null)" == "" ] || \
		exe docker rmi -f $name
  return 0
}

clean () {
	# Remove all references to the image and container
	remove
	removeimage
	[ -f "$build_dir/pipework" ] && exe rm "$build_dir/pipework"
  return 0
}

firewall () {
	# TODO: Add iptables config
	:
}

install () {
	# Create systemd service file from template and register it

  unit_template | \
  while read line; do
	  eval echo "$line"
	done >/tmp/$name.service
	exe cp /tmp/$name.service /usr/lib/systemd/system/$name.service
	exe systemctl daemon-reload
	exe systemctl enable $name
}

uninstall () {
	# Uninstall the system service
	exe systemctl disable $name
	exe rm /usr/lib/systemd/system/$name.service
  exe systemctl daemon-reload
}

ps () {
	docker ps
}

cleanuntagged () {
	# Remove all untagged images
  # shellcheck disable=SC2046
	exe docker rmi $(docker images | awk '/^<none>/ { print $3 }')
}

cleanall () {
	# Remove all docker images and containers
  # shellcheck disable=SC2046
	exe docker rm $(docker ps -aq)
  # shellcheck disable=SC2046
  exe docker rmi $(docker images -q)
}

isfn () {
  # Is $1 contained in $fns?
  for s in $fns; do
    [ "$1" == "$s" ] && return 0
  done
  return 1
}


command_loop () {
  # Command line parameters are evaluated as functions if they are contained in
  # this file or the DWfile. Otherwise, they are passed as arguments to the
  # preceding function
  while [ -n "$*" ]; do
    cmd=$1
    shift
    params=
    while [ -n "$*" ] && ! isfn "$1"; do
      params+="$1 "
      shift
    done
  	echo -e "$WHITE==> $CYAN$cmd$NO_COLOR $params"
  	if ! $cmd $params; then
      echo "Aborting because a command encountered an error"
      exit 1
    fi
  done
}

## MAIN

command_loop "$@"
